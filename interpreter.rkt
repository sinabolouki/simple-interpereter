#lang racket

(require racket/include)
(require "environment.rkt")
(require "myParser.rkt")
(require "ops.rkt")
(require (except-in eopl #%module-begin))


(define-namespace-anchor anc)
(define ns (namespace-anchor->namespace anc))

(define value-of
  (lambda (tree env)
    (let ((action (car tree)))
      (cond
        ((equal? action 'command)
         (let ((result (value-of (cadr tree) env)))
           (if (equal? (caddr result) 'END)
               (list (car result) (cadr result) 'END)
               (value-of (caddr tree) (cadr result)))
          ))
        
        ((equal? action 'if)
         (let* ((exp-result (value-of (cadr tree) env))
                (new-env (cadr exp-result)))
           (if (car exp-result)
               (value-of (caddr tree) new-env)
               (value-of (cadddr tree) new-env))
           )
         )

         ((equal? action 'eq)
         (let ((result (value-of (caddr tree) env)))
           (list (car result) (extend-env (cadr tree) (car result) (cadr result)) 'NOTEND)
           )
         )


        ((equal? action 'while)
         (let ((exp-result (value-of (cadr tree) env)))
           (if (and (car exp-result) (not (eqv? (caddr exp-result) 'END)))
               (let* ((new-env (cadr exp-result))
                      (command-result (value-of (caddr tree) new-env)))
                 (if (not (eqv? (caddr command-result) 'END))
                     (let ((condition-new-env (cadr command-result)))
                       (value-of tree condition-new-env))
                      command-result)
                 )
                 exp-result
             )
           )
         )

        ((equal? action 'ret)
         (let ((result (value-of (cadr tree) env)))
           (list (car result) (cadr result) 'END)
           )
         )

        ((equal? action 'grt)
         (let* ((valu (value-of (cadr tree) env))
           (left-operand (car valu))
           (new-env (cadr valu))
           (val-left (value-of (caddr tree) env))
           (right-operand (car val-left))
           (second-new-env (cadr val-left)))
           (list (gr? left-operand right-operand) second-new-env 'NOTEND)
           )
        )

        ((equal? action 'less)
         (let* ((valu (value-of (cadr tree) env))
           (left-operand (car valu))
           (new-env (cadr valu))
           (val-left (value-of (caddr tree) env))
           (right-operand (car val-left))
           (second-new-env (cadr val-left)))
           (list (ls? left-operand right-operand) second-new-env 'NOTEND)
           )
        )

        ((equal? action 'sub)
         (let* ((valu (value-of (cadr tree) env))
           (left-operand (car valu))
           (new-env (cadr valu))
           (val-left (value-of (caddr tree) env))
           (right-operand (car val-left))
           (second-new-env (cadr val-left)))
           (list (arith-op left-operand "-" right-operand) second-new-env 'NOTEND)
           )
        )

        ((equal? action 'add)
         (let* ((valu (value-of (cadr tree) env))
           (left-operand (car valu))
           (new-env (cadr valu))
           (val-left (value-of (caddr tree) env))
           (right-operand (car val-left))
           (second-new-env (cadr val-left)))
           (list (arith-op left-operand "+" right-operand) second-new-env 'NOTEND)
           )
        )

        ((equal? action 'mul)
         (cond
           ((equal? (car (value-of (cadr tree) env)) 0) (list 0 env 'NOTEND))
           ((equal? (car (value-of (cadr tree) env)) #f) (list #f 'NOTEND))
           (else (list (arith-op (car (value-of (cadr tree) env)) "*" (car (value-of (caddr tree) env))) (cadr (value-of (caddr tree) env)) 'NOTEND)))
        )

        ((equal? action 'div)
         (let* ((valu (value-of (cadr tree) env))
           (left-operand (car valu))
           (new-env (cadr valu))
           (val-left (value-of (caddr tree) env))
           (right-operand (car val-left))
           (second-new-env (cadr val-left)))
           (list (arith-op left-operand "/" right-operand) second-new-env 'NOTEND)
           )
        )
		
		((equal? action 'iseq)
         (let* ((valu (value-of (cadr tree) env))
           (left-operand (car valu))
           (new-env (cadr valu))
           (val-left (value-of (caddr tree) env))
           (right-operand (car val-left))
           (second-new-env (cadr val-left)))
           (list (equality? left-operand right-operand) second-new-env 'NOTEND)
           )
        )

        ((equal? action 'isneq)
         (let* ((valu (value-of (cadr tree) env))
           (left-operand (car valu))
           (new-env (cadr valu))
           (val-left (value-of (caddr tree) env))
           (right-operand (car val-left))
           (second-new-env (cadr val-left)))
           (list (inequality? left-operand right-operand) second-new-env 'NOTEND)
           )
        )
        
        ((equal? action 'bool) (list (cadr tree) env 'NOTEND))
        ((equal? action 'num) (list (cadr tree) env 'NOTEND))
        ((equal? action 'str) (list (cadr tree) env 'NOTEND))
        ((equal? action 'var) (list (apply-env env (cadr tree)) env 'NOTEND))
        ((equal? action 'list) (value-of (cadr tree) env 'NOTEND))
        ((equal? action 'par-exp) (value-of (cadr tree) env))
        ((equal? action 'null) (list '() env 'NOTEND))
		((equal? action 'neg)
         (let* ((valu (value-of (cadr tree) env))
           (oper (car valu))
           (new-env (cadr valu)))
           (list (negate oper) new-env 'NOTEND)
           )
        )

        ((equal? action 'accessmember)
         (let* ((result-indices (value-of (caddr tree) env))
                (indices (car result-indices))
                (new-env (cadr result-indices))
                (li (apply-env env (cadr tree))))
           (list (get-item li indices) new-env 'NOTEND)
           )
         )
		 
		((equal? action 'emptylist) (list '() env 'NOTEND))

        ((equal? action 'listvalues) (value-of (cadr tree) env))

        ((equal? action 'listval)
         (let ((result (value-of (cadr tree) env)))
           (list (list (car result)) (cadr result) 'NOTEND)
           )
         )
        
        ((equal? action 'listvals)
         (let* ((result-val (value-of (cadr tree) env))
                (result-vals (value-of (caddr tree) (cadr result-val))))
           (list (cons (car result-val) (car result-vals)) (cadr result-vals) 'NOTEND)
           )
         )

        ((equal? action 'listmember)
         (let ((result (value-of (cadr tree) env)))
           (list (list (car result)) (cadr result) 'NOTEND)
           )
         )
        
        ((equal? action 'list-members)
         (let* ((result-val (value-of (cadr tree) env))
                (result-vals (value-of (caddr tree) (cadr result-val))))
           (list (cons (car result-val) (car result-vals)) (cadr result-vals) 'NOTEND)
           )
         )
		 
		((equal? action 'print)
         (let ((result (value-of (cadr tree) env)))
           (display (car result))
           (display "\n")
           (list (car result) (cadr result) 'NOTEND)
           )
         )
        )
      )
    )
  )

(define list-ref
  (lambda (li index)
    (cond
      [(not (list? li)) (type-error li)]
      [(<= (length li) index) (bound-error li index)]
      [else (if (= index 0)
            (car li)
            (list-ref (cdr li) (- index 1)))]
      )
    )
  )

(define bound-error
  (lambda (li index)
    (eopl:error 'apply-env "List ~s Out of Bounds for Index ~s" li index)
    )
  )

(define type-error
  (lambda (li)
    (eopl:error 'apply-env "~s List type error" li)
    )
  )

(define get-item
  (lambda (li indices)
    (if (zero? (length indices))
        li
        (get-item (list-ref li (car indices)) (cdr indices))
      )
    )
  )

(define interpret
  (lambda (path)
    (define input-string (file->string path))
    (define lex-this (lambda (lexer input) (lambda () (lexer input))))
    (define my-lexer (lex-this simple-lexer (open-input-string input-string)))
    (let((parser-res (simple-parser my-lexer)))
        (car (value-of parser-res (empty-env)))
      )
    )
  )

(interpret "test.txt")